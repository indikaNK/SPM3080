/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package timeManage;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.IllegalComponentStateException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.UIManager;
import static javax.swing.WindowConstants.DISPOSE_ON_CLOSE;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

/**
 *
 * @author Thisura
 */
public class CustomTableModel extends javax.swing.JInternalFrame {

    /**
     * Creates new form CustomTableModel
     */
    
    private static final boolean locationByPlatformProp = false;
    private volatile boolean locationByPlatform = locationByPlatformProp;
    public CustomTableModel() {}
    public CustomTableModel(Object[][] dataVector, Object[] columnIdentifiers) {
        super("Y1.S1.01(IT)");
        
        
//                initComponents();

        JTextArea jta = new JTextArea("gjhhjgg\nkjhkhk");
        
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        DefaultTableModel dm = new DefaultTableModel() {
          public Class<String> getColumnClass(int columnIndex) {
            return String.class;
          }
          public boolean isCellEditable(int row, int column) {
            return false;
          }
        };
//        dm.setDataVector(
//            new Object[][]{
//                {"8.30", 
//                 "It2030-OOP (Lecture)\nY2S1.03(IT)\nA507\n(LT,LS)", 
//                 "",
//                 "",
//                 "",
//                 "It2030-OOP (Lecture)\nY2S1.03(IT)\nA507\n(LT,LS)"
//                }, 
//                {"A1, Line1", 
//                 "B1, Line1\nB1, Line2", 
//                 "C1, Line1"},
//                {"A2, Line1", 
//                 "B2, Line1", 
//                 "C2, Line1"}
//                }, 
//                new Object[] {"", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"});
        dm.setDataVector(dataVector, columnIdentifiers);

        JTable table = new JTable(dm);
        table.setDefaultRenderer(String.class, new MultiLineTableCellRenderer());
        TableRowSorter<? extends TableModel> sort = new TableRowSorter<DefaultTableModel>(dm);
        table.setRowSorter(sort);
        JScrollPane scroll = new JScrollPane(table);
        getContentPane().add(scroll);
        setLocationByPlatform(true);
        setSize(400, 430);
        setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 394, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 274, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void setLocationByPlatform(boolean locationByPlatform) {
        synchronized (getTreeLock()) {
            if (locationByPlatform && isShowing()) {
                throw new IllegalComponentStateException("The window is showing on screen.");
            }
            this.locationByPlatform = locationByPlatform;
        }
    }
    
    public class MultiLineTableCellRenderer extends JTextArea 
        implements TableCellRenderer {
        private List<List<Integer>> rowColHeight = new ArrayList<List<Integer>>();

        public MultiLineTableCellRenderer() {
          setLineWrap(true);
          setWrapStyleWord(true);
          setOpaque(true);
        }

        public Component getTableCellRendererComponent(
            JTable table, Object value, boolean isSelected, boolean hasFocus,
            int row, int column) {
          if (isSelected) {
            setForeground(table.getSelectionForeground());
            setBackground(table.getSelectionBackground());
          } else {
            setForeground(table.getForeground());
            setBackground(table.getBackground());
          }
          setFont(table.getFont());
          if (hasFocus) {
            setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
            if (table.isCellEditable(row, column)) {
              setForeground(UIManager.getColor("Table.focusCellForeground"));
              setBackground(UIManager.getColor("Table.focusCellBackground"));
            }
          } else {
            setBorder(new EmptyBorder(1, 2, 1, 2));
          }
          if (value != null) {
            setText(value.toString());
          } else {
            setText("");
          }
          adjustRowHeight(table, row, column);
          return this;
        }

        /**
         * Calculate the new preferred height for a given row, and sets the height on the table.
         */
        private void adjustRowHeight(JTable table, int row, int column) {
          //The trick to get this to work properly is to set the width of the column to the 
          //textarea. The reason for this is that getPreferredSize(), without a width tries 
          //to place all the text in one line. By setting the size with the with of the column, 
          //getPreferredSize() returnes the proper height which the row should have in
          //order to make room for the text.
          int cWidth = table.getTableHeader().getColumnModel().getColumn(column).getWidth();
          setSize(new Dimension(cWidth, 1000));
          int prefH = getPreferredSize().height;
          while (rowColHeight.size() <= row) {
            rowColHeight.add(new ArrayList<Integer>(column));
          }
          List<Integer> colHeights = rowColHeight.get(row);
          while (colHeights.size() <= column) {
            colHeights.add(0);
          }
          colHeights.set(column, prefH);
          int maxH = prefH;
          for (Integer colHeight : colHeights) {
            if (colHeight > maxH) {
              maxH = colHeight;
            }
          }
          if (table.getRowHeight(row) != maxH) {
            table.setRowHeight(row, maxH);
          }
        }}
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
